public class IntCount {
    public static void main(String[] args){
        int i = (100 + 200) * (99 - 88); // 3300
        int n = 7 * (5 + (i - 9)); // 23072
        System.out.println(i);
        System.out.println(n);

        //整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分：
        int x = 12345 / 67; // 184
        int y = 12345 % 67; // 12345÷67的余数是17
        System.out.println(x);
        System.out.println(y);
        //特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。

        //溢出
        int a = 2147483640;
        int b = 15;
        int sum = a + b;
        System.out.println(sum); // -2147483641
        /*
        int类型能表示的最大范围如下：
        int: -2147483648 ~ 2147483647
        如果把int换成long类型，就不会溢出
        */

        //自增与自减
        //注意++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1
        int n1 = 3300;
        n1++; // 3301, 相当于 n = n + 1;
        n1--; // 3300, 相当于 n = n - 1;
        int y1 = 100 + (++n1); // 不建议把++运算混入到常规运算中
        System.out.println("y1 = " + y1);

        /*
        //移位运算
        //可以对整数进行移位运算。对整数7左移1位将得到整数14，左移两位将得到整数28：
        int n = 7;       // 00000000 00000000 00000000 00000111 = 7
        int a = n << 1;  // 00000000 00000000 00000000 00001110 = 14
        int b = n << 2;  // 00000000 00000000 00000000 00011100 = 28
        int c = n << 28; // 01110000 00000000 00000000 00000000 = 1879048192
        int d = n << 29; // 11100000 00000000 00000000 00000000 = -536870912
        //左移29位时，由于最高位变成1，因此结果变成了负数。

        //类似的，对整数28进行右移，结果如下：
        int n = 7;       // 00000000 00000000 00000000 00000111 = 7
        int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
        int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
        int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0

        //如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数：
        int n = -536870912;
        int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
        int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
        int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
        int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1

        //还有一种无符号的右移运算，使用>>>
        //它的特点是不管符号位，右移后高位总是补0
        //因此，对一个负数进行>>>右移，它会变成正数，原因是最高位的1变成了0：
        int n = -536870912;
        int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
        int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
        int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
        int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1

        //对byte和short类型进行移位时，会首先转换为int再进行位移。
        */

        /*位运算
        位运算是按位进行与、或、非和异或的运算

        与运算的规则是，必须两个数同时为1，结果才为1：
        n = 0 & 0; // 0
        n = 0 & 1; // 0
        n = 1 & 0; // 0
        n = 1 & 1; // 1

        或运算的规则是，只要任意一个为1，结果就为1：
        n = 0 | 0; // 0
        n = 0 | 1; // 1
        n = 1 | 0; // 1
        n = 1 | 1; // 1

        非运算的规则是，0和1互换：
        n = ~0; // 1
        n = ~1; // 0

        异或运算的规则是，如果两个数不同，结果为1，否则为0：
        n = 0 ^ 0; // 0
        n = 0 ^ 1; // 1
        n = 1 ^ 0; // 1
        n = 1 ^ 1; // 0
        */
        //对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。
        //下面的例子进行了一次与运算：
        int ii = 167776589; // 00001010 00000000 00010001 01001101
        int nn = 167776512; // 00001010 00000000 00010001 00000000
        System.out.println(ii & nn); // 167776512
        //上述按位与运算实际上可以看作两个整数表示的IP地址10.0.17.77和10.0.17.0
        //通过与运算，可以快速判断一个IP是否在给定的网段内。

        //类型自动提升与强制转型
        //在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。
        //例如，short和int计算，结果总是int，原因是short首先自动被转型为int：
        short s = 1234;
        int iii = 123456;
        int xx = s + iii; // s自动转型为int
        //short yy = s + iii; // 编译错误! java: 不兼容的类型: 从int转换到short可能会有损失
        System.out.println(xx);

        //要注意，超出范围的强制转型会得到错误的结果，原因是转型时，int的两个高位字节直接被扔掉，仅保留了低位的两个字节：
        int i1 = 1234567;
        short s1 = (short) i1; // -10617
        System.out.println(s1);
        int i2 = 12345678;
        short s2 = (short) i2; // 24910
        System.out.println(s2);
    }
}
